/* Author: Wolfgang Bangerth, Texas A&M University, 2006 */

/*    $Id: step-23.cc 25840 2012-08-09 20:22:00Z bangerth $       */
/*    Version: $Name:  $                                          */
/*                                                                */
/*    Copyright (C) 2006, 2007, 2008, 2009, 2011, 2012 by the deal.II authors */
/*                                                                */
/*    This file is subject to QPL and may not be  distributed     */
/*    without copyright and license information. Please refer     */
/*    to the file deal.II/doc/license.html for the  text  and     */
/*    further information on this license.                        */


                                 // @sect3{Include files}

                                 // We start with the usual assortment
                                 // of include files that we've seen
                                 // in so many of the previous tests:
#include <deal.II/base/quadrature_lib.h>
#include <deal.II/base/function.h>
#include <deal.II/base/logstream.h>

#include <deal.II/lac/vector.h>
#include <deal.II/lac/full_matrix.h>
#include <deal.II/lac/sparse_matrix.h>
#include <deal.II/lac/solver_cg.h>
#include <deal.II/lac/precondition.h>
#include <deal.II/lac/constraint_matrix.h>

#include <deal.II/grid/tria.h>
#include <deal.II/grid/grid_generator.h>
#include <deal.II/grid/tria_accessor.h>
#include <deal.II/grid/tria_iterator.h>

#include <deal.II/dofs/dof_handler.h>
#include <deal.II/dofs/dof_accessor.h>
#include <deal.II/dofs/dof_tools.h>

#include <deal.II/fe/fe_q.h>
#include <deal.II/fe/fe_values.h>

#include <deal.II/numerics/data_out.h>

#include <fstream>
#include <iostream>

                                 // Here are the only three include
                                 // files of some new interest: The
                                 // first one is already used, for
                                 // example, for the
                                 // VectorTools::interpolate_boundary_values
                                 // and
                                 // VectorTools::apply_boundary_values
                                 // functions. However, we here use
                                 // another function in that class,
                                 // VectorTools::project to compute
                                 // our initial values as the $L^2$
                                 // projection of the continuous
                                 // initial values. Furthermore, we
                                 // use
                                 // VectorTools::create_right_hand_side
                                 // to generate the integrals
                                 // $(f^n,\phi^n_i)$. These were
                                 // previously always generated by
                                 // hand in
                                 // <code>assemble_system</code> or
                                 // similar functions in application
                                 // code. However, we're too lazy to
                                 // do that here, so simply use a
                                 // library function:
#include <deal.II/numerics/vector_tools.h>

                                 // In a very similar vein, we are
                                 // also too lazy to write the code to
                                 // assemble mass and Laplace
                                 // matrices, although it would have
                                 // only taken copying the relevant
                                 // code from any number of previous
                                 // tutorial programs. Rather, we want
                                 // to focus on the things that are
                                 // truly new to this program and
                                 // therefore use the
                                 // MatrixTools::create_mass_matrix
                                 // and
                                 // MatrixTools::create_laplace_matrix
                                 // functions. They are declared here:
#include <deal.II/numerics/matrix_tools.h>

                                 // Finally, here is an include file
                                 // that contains all sorts of tool
                                 // functions that one sometimes
                                 // needs. In particular, we need the
                                 // Utilities::int_to_string class
                                 // that, given an integer argument,
                                 // returns a string representation of
                                 // it. It is particularly useful
                                 // since it allows for a second
                                 // parameter indicating the number of
                                 // digits to which we want the result
                                 // padded with leading zeros. We will
                                 // use this to write output files
                                 // that have the form
                                 // <code>solution-XXX.gnuplot</code>
                                 // where <code>XXX</code> denotes the
                                 // number of the time step and always
                                 // consists of three digits even if
                                 // we are still in the single or
                                 // double digit time steps.
#include <deal.II/base/utilities.h>

                                 // The last step is as in all
                                 // previous programs:
namespace Step23
{
  using namespace dealii;


                                   // @sect3{The <code>WaveEquation</code> class}

                                   // Next comes the declaration of the main
                                   // class. It's public interface of functions
                                   // is like in most of the other tutorial
                                   // programs. Worth mentioning is that we now
                                   // have to store four matrices instead of
                                   // one: the mass matrix $M$, the Laplace
                                   // matrix $A$, the matrix $M+k^2\theta^2A$
                                   // used for solving for $U^n$, and a copy of
                                   // the mass matrix with boundary conditions
                                   // applied used for solving for $V^n$. Note
                                   // that it is a bit wasteful to have an
                                   // additional copy of the mass matrix
                                   // around. We will discuss strategies for how
                                   // to avoid this in the section on possible
                                   // improvements.
                                   //
                                   // Likewise, we need solution vectors for
                                   // $U^n,V^n$ as well as for the corresponding
                                   // vectors at the previous time step,
                                   // $U^{n-1},V^{n-1}$. The
                                   // <code>system_rhs</code> will be used for
                                   // whatever right hand side vector we have
                                   // when solving one of the two linear systems
                                   // in each time step. These will be solved in
                                   // the two functions <code>solve_u</code> and
                                   // <code>solve_v</code>.
                                   //
                                   // Finally, the variable
                                   // <code>theta</code> is used to
                                   // indicate the parameter $\theta$
                                   // that is used to define which time
                                   // stepping scheme to use, as
                                   // explained in the introduction. The
                                   // rest is self-explanatory.
  template <int dim>
  class WaveEquation
  {
    public:
      WaveEquation ();
      void run ();

    private:
      void setup_system ();
      void solve_u ();
      void output_results () const;

      Triangulation<dim>   triangulation;
      FE_Q<dim>            fe;
      DoFHandler<dim>      dof_handler;

      ConstraintMatrix constraints;

      SparsityPattern      sparsity_pattern;
      SparseMatrix<double> mass_matrix;
      SparseMatrix<double> laplace_matrix;
      SparseMatrix<double> matrix_u;

      Vector<double>       solution_u;
      Vector<double>       old_solution_u;
      Vector<double>       system_rhs;

      double time, time_step;
      unsigned int timestep_number;
      const double theta;
  };



                                   // @sect3{Equation data}

                                   // Before we go on filling in the
                                   // details of the main class, let us
                                   // define the equation data
                                   // corresponding to the problem,
                                   // i.e. initial and boundary values
                                   // for both the solution $u$ and its
                                   // time derivative $v$, as well as a
                                   // right hand side class. We do so
                                   // using classes derived from the
                                   // Function class template that has
                                   // been used many times before, so
                                   // the following should not be a
                                   // surprise.
                                   //
                                   // Let's start with initial values
                                   // and choose zero for both the value
                                   // $u$ as well as its time
                                   // derivative, the velocity $v$:
  template <int dim>
  class InitialValuesU : public Function<dim>
  {
    public:
      InitialValuesU () : Function<dim>() {}

      virtual double value (const Point<dim>   &p,
                            const unsigned int  component = 0) const;
  };


  template <int dim>
  double InitialValuesU<dim>::value (const Point<dim>  &p,
                                     const unsigned int component) const
  {
    Assert (component == 0, ExcInternalError());
     if (p[0]*p[0] + p[1]*p[1]>0.7*0.7 )return 0.0;
     else if (p[0]*p[0] + p[1]*p[1]<0.7*0.7 && p[0]*p[0] + p[1]*p[1]>0.5*0.5)return -sin((sqrt(p[0]*p[0] + p[1]*p[1])-0.6)/0.1*numbers::PI/2)*0.5+0.5;
     else return 1.0;
  }

                                   // Secondly, we have the right hand
                                   // side forcing term. Boring as we
                                   // are, we choose zero here as well:
  template <int dim>
  class RightHandSide : public Function<dim>
  {
    public:
      RightHandSide () : Function<dim>() {}

      virtual double value (const Point<dim>   &p,
                            const unsigned int  component = 0) const;
  };



  template <int dim>
  double RightHandSide<dim>::value (const Point<dim>  &p,
                                    const unsigned int component) const
  {
     Assert (component == 0, ExcInternalError());
     return 0;
  }



                                   // Finally, we have boundary values for $u$
                                   // and $v$. They are as described in the
                                   // introduction, one being the time
                                   // derivative of the other:
  template <int dim>
  class BoundaryValuesU : public Function<dim>
  {
    public:
      BoundaryValuesU () : Function<dim>() {}

      virtual double value (const Point<dim>   &p,
                            const unsigned int  component = 0) const;
  };


  template <int dim>
  double BoundaryValuesU<dim>::value (const Point<dim> &p,
                                      const unsigned int component) const
  {
    Assert (component == 0, ExcInternalError());
    return 0;
  }

                                   // @sect3{Implementation of the <code>WaveEquation</code> class}

                                   // The implementation of the actual logic is
                                   // actually fairly short, since we relegate
                                   // things like assembling the matrices and
                                   // right hand side vectors to the
                                   // library. The rest boils down to not much
                                   // more than 130 lines of actual code, a
                                   // significant fraction of which is
                                   // boilerplate code that can be taken from
                                   // previous example programs (e.g. the
                                   // functions that solve linear systems, or
                                   // that generate output).
                                   //
                                   // Let's start with the constructor (for an
                                   // explanation of the choice of time step,
                                   // see the section on Courant, Friedrichs,
                                   // and Lewy in the introduction):
  template <int dim>
  WaveEquation<dim>::WaveEquation () :
                  fe (1),
                  dof_handler (triangulation),
                  time_step (1./64),
                  theta (0.5)
  {}


                                   // @sect4{WaveEquation::setup_system}

                                   // The next function is the one that
                                   // sets up the mesh, DoFHandler, and
                                   // matrices and vectors at the
                                   // beginning of the program,
                                   // i.e. before the first time
                                   // step. The first few lines are
                                   // pretty much standard if you've
                                   // read through the tutorial programs
                                   // at least up to step-6:
  template <int dim>
  void WaveEquation<dim>::setup_system ()
  {
    GridGenerator::hyper_cube (triangulation, -1, 1);
    triangulation.refine_global (7);

    std::cout << "Number of active cells: "
              << triangulation.n_active_cells()
              << std::endl;

    dof_handler.distribute_dofs (fe);

    std::cout << "Number of degrees of freedom: "
              << dof_handler.n_dofs()
              << std::endl
              << std::endl;

    sparsity_pattern.reinit (dof_handler.n_dofs(),
                             dof_handler.n_dofs(),
                             dof_handler.max_couplings_between_dofs());
    DoFTools::make_sparsity_pattern (dof_handler, sparsity_pattern);
    sparsity_pattern.compress();

                                     // Then comes a block where we have to
                                     // initialize the 3 matrices we need in the
                                     // course of the program: the mass matrix,
                                     // the laplace matrix, and the matrix
                                     // $M+k^2\theta^2A$ used when solving for
                                     // $U^n$ in each time step.
                                     //
                                     // When setting up these matrices, note
                                     // that they all make use of the same
                                     // sparsity pattern object. Finally, the
                                     // reason why matrices and sparsity
                                     // patterns are separate objects in deal.II
                                     // (unlike in many other finite element or
                                     // linear algebra classes) becomes clear:
                                     // in a significant fraction of
                                     // applications, one has to hold several
                                     // matrices that happen to have the same
                                     // sparsity pattern, and there is no reason
                                     // for them not to share this information,
                                     // rather than re-building and wasting
                                     // memory on it several times.
                                     //
                                     // After initializing all of these
                                     // matrices, we call library functions that
                                     // build the Laplace and mass matrices. All
                                     // they need is a DoFHandler object and a
                                     // quadrature formula object that is to be
                                     // used for numerical integration. Note
                                     // that in many respects these functions
                                     // are better than what we would usually do
                                     // in application programs, for example
                                     // because they automatically parallelize
                                     // building the matrices if multiple
                                     // processors are available in a
                                     // machine. The matrices for solving linear
                                     // systems will be filled in the run()
                                     // method because we need to re-apply
                                     // boundary conditions every time step.
    mass_matrix.reinit (sparsity_pattern);
    laplace_matrix.reinit (sparsity_pattern);
    matrix_u.reinit (sparsity_pattern);

    MatrixCreator::create_mass_matrix (dof_handler, QGauss<dim>(3),
                                       mass_matrix);
    MatrixCreator::create_laplace_matrix (dof_handler, QGauss<dim>(3),
                                          laplace_matrix);

                                     // The rest of the function is spent on
                                     // setting vector sizes to the correct
                                     // value. The final line closes the hanging
                                     // node constraints object. Since we work
                                     // on a uniformly refined mesh, no
                                     // constraints exist or have been computed
                                     // (i.e. there was no need to call
                                     // DoFTools::make_hanging_node_constraints
                                     // as in other programs), but we need a
                                     // constraints object in one place further
                                     // down below anyway.
    solution_u.reinit (dof_handler.n_dofs());
    old_solution_u.reinit (dof_handler.n_dofs());
    system_rhs.reinit (dof_handler.n_dofs());

    constraints.close ();
  }


                                   // @sect4{WaveEquation::solve_u and WaveEquation::solve_v}

                                   // The next two functions deal with solving
                                   // the linear systems associated with the
                                   // equations for $U^n$ and $V^n$. Both are
                                   // not particularly interesting as they
                                   // pretty much follow the scheme used in all
                                   // the previous tutorial programs.
                                   //
                                   // One can make little experiments with
                                   // preconditioners for the two matrices we
                                   // have to invert. As it turns out, however,
                                   // for the matrices at hand here, using
                                   // Jacobi or SSOR preconditioners reduces the
                                   // number of iterations necessary to solve
                                   // the linear system slightly, but due to the
                                   // cost of applying the preconditioner it is
                                   // no win in terms of run-time. It is not
                                   // much of a loss either, but let's keep it
                                   // simple and just do without:
  template <int dim>
  void WaveEquation<dim>::solve_u ()
  {
    SolverControl           solver_control (1000, 1e-8*system_rhs.l2_norm());
    SolverCG<>              cg (solver_control);

    cg.solve (matrix_u, solution_u, system_rhs,
              PreconditionIdentity());

    std::cout << "   u-equation: " << solver_control.last_step()
              << " CG iterations."
              << std::endl;
  }

                                   // @sect4{WaveEquation::output_results}

                                   // Likewise, the following function is pretty
                                   // much what we've done before. The only
                                   // thing worth mentioning is how here we
                                   // generate a string representation of the
                                   // time step number padded with leading zeros
                                   // to 3 character length using the
                                   // Utilities::int_to_string function's second
                                   // argument.
  template <int dim>
  void WaveEquation<dim>::output_results () const
  {
    DataOut<dim> data_out;

    data_out.attach_dof_handler (dof_handler);
    data_out.add_data_vector (solution_u, "U");

    data_out.build_patches ();

    const std::string filename = "solution-" +
                                 Utilities::int_to_string (timestep_number, 3) +
                                 ".vtk";
    std::ofstream output (filename.c_str());
    data_out.write_vtk (output);
  }




                                   // @sect4{WaveEquation::run}

                                   // The following is really the only
                                   // interesting function of the program. It
                                   // contains the loop over all time steps, but
                                   // before we get to that we have to set up
                                   // the grid, DoFHandler, and matrices. In
                                   // addition, we have to somehow get started
                                   // with initial values. To this end, we use
                                   // the VectorTools::project function that
                                   // takes an object that describes a
                                   // continuous function and computes the $L^2$
                                   // projection of this function onto the
                                   // finite element space described by the
                                   // DoFHandler object. Can't be any simpler
                                   // than that:
  template <int dim>
  void WaveEquation<dim>::run ()
  {
    setup_system();

    VectorTools::project (dof_handler, constraints, QGauss<dim>(3),
                          InitialValuesU<dim>(),
                          old_solution_u);

    Vector<double> tmp (solution_u.size());
    Vector<double> forcing_terms (solution_u.size());

    for (timestep_number=1, time=time_step;
         time<=5;
         time+=time_step, ++timestep_number)
      {
        std::cout << "Time step " << timestep_number
                  << " at t=" << time
                  << std::endl;

        RightHandSide<dim> rhs_function;
        rhs_function.set_time (time);
        VectorTools::create_right_hand_side (dof_handler, QGauss<dim>(2),
                                             rhs_function, tmp);
        forcing_terms = tmp;
        forcing_terms *= theta * time_step;

        rhs_function.set_time (time-time_step);
        VectorTools::create_right_hand_side (dof_handler, QGauss<dim>(2),
                                             rhs_function, tmp);

        forcing_terms.add ((1-theta) * time_step, tmp);

        system_rhs.add (theta * time_step, forcing_terms);




        laplace_matrix.vmult (system_rhs, solution_u);
        system_rhs *= -theta * time_step;

        mass_matrix.vmult (tmp, old_solution_u);
        system_rhs += tmp;

        laplace_matrix.vmult (tmp, old_solution_u);
        system_rhs.add (-time_step * (1-theta), tmp);

        system_rhs += forcing_terms;

        {
          BoundaryValuesU<dim> boundary_values_u_function;
          boundary_values_u_function.set_time (time);

          std::map<unsigned int,double> boundary_values;
          VectorTools::interpolate_boundary_values (dof_handler,
                                                    0,
                                                    boundary_values_u_function,
                                                    boundary_values);
          matrix_u.copy_from (mass_matrix);
          MatrixTools::apply_boundary_values (boundary_values,
                                              matrix_u,
                                              solution_u,
                                              system_rhs);
        }
        solve_u();

                                         // Finally, after both solution
                                         // components have been computed, we
                                         // output the result, compute the
                                         // energy in the solution, and go on to
                                         // the next time step after shifting
                                         // the present solution into the
                                         // vectors that hold the solution at
                                         // the previous time step. Note the
                                         // function
                                         // SparseMatrix::matrix_norm_square
                                         // that can compute
                                         // $\left<V^n,MV^n\right>$ and
                                         // $\left<U^n,AU^n\right>$ in one step,
                                         // saving us the expense of a temporary
                                         // vector and several lines of code:
        output_results ();

        std::cout << "   Total energy: "
                  << (laplace_matrix.matrix_norm_square (solution_u)) / 2
                  << std::endl;

        old_solution_u = solution_u;
      }
  }
}


                                 // @sect3{The <code>main</code> function}

                                 // What remains is the main function of the
                                 // program. There is nothing here that hasn't
                                 // been shown in several of the previous
                                 // programs:
int main ()
{
  try
    {
      using namespace dealii;
      using namespace Step23;

      deallog.depth_console (0);

      WaveEquation<2> wave_equation_solver;
      wave_equation_solver.run ();
    }
  catch (std::exception &exc)
    {
      std::cerr << std::endl << std::endl
                << "----------------------------------------------------"
                << std::endl;
      std::cerr << "Exception on processing: " << std::endl
                << exc.what() << std::endl
                << "Aborting!" << std::endl
                << "----------------------------------------------------"
                << std::endl;

      return 1;
    }
  catch (...)
    {
      std::cerr << std::endl << std::endl
                << "----------------------------------------------------"
                << std::endl;
      std::cerr << "Unknown exception!" << std::endl
                << "Aborting!" << std::endl
                << "----------------------------------------------------"
                << std::endl;
      return 1;
    }

  return 0;
}
